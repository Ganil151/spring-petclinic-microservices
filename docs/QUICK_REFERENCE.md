# Terraform & Ansible Quick Reference

## ğŸ“ Directory Structure
```
terraform/
â”œâ”€â”€ shared/          # Reference templates (4 files)
â”œâ”€â”€ environments/    # Environment configs (dev, staging, prod)
â”‚   â””â”€â”€ dev/templates/ansible_inventory.tftpl  # Inventory template
â”œâ”€â”€ modules/         # Reusable infrastructure modules
â”œâ”€â”€ global/          # Global resources (IAM, Route53)
â””â”€â”€ scripts/         # Bare-minimum EC2 user_data (hostname + python3)

ansible/
â”œâ”€â”€ ansible.cfg          # SSH config, pipelining, privilege escalation
â”œâ”€â”€ inventory/
â”‚   â””â”€â”€ dynamic_hosts    # âš¡ Auto-generated by Terraform
â”œâ”€â”€ roles/               # One role per tool
â”‚   â”œâ”€â”€ java/  docker/  awscli/  maven/  kubectl/  helm/
â”‚   â”œâ”€â”€ jenkins/         # Full Jenkins Master setup
â”‚   â”œâ”€â”€ sonarqube/       # Kernel tuning + Docker Compose stack
â”‚   â””â”€â”€ security_tools/  # Trivy + Checkov
â””â”€â”€ playbooks/
    â””â”€â”€ install-tools.yml  # 5-play orchestration
```

## ğŸš€ Common Commands

### Deploy Infrastructure (Terraform)
```bash
cd terraform/environments/dev
terraform init

# 1. Set Database Password (Required for RDS)
export TF_VAR_db_password="YourSecurePassword123"

# 2. Plan and Apply
terraform plan -out=tfplan
terraform apply tfplan
```

### Configure Instances (Ansible)
```bash
# After terraform apply generates inventory:
cd ansible
ansible-playbook playbooks/install-tools.yml

# Dry-run (check mode):
ansible-playbook playbooks/install-tools.yml --check

# Target a specific play/group:
ansible-playbook playbooks/install-tools.yml --limit jenkins_master
ansible-playbook playbooks/install-tools.yml --limit build_agents

# Verify connectivity first:
ansible all -m ping
```

### View Terraform Outputs
```bash
terraform output                    # All outputs
terraform output tool_mapping       # Which tools go where
terraform output ansible_command    # Ready-to-run Ansible command
terraform output jenkins_master_url # Jenkins Web UI URL
terraform output sonarqube_url      # SonarQube Web UI URL
terraform output rds_endpoint       # MySQL Connection string
terraform output eks_cluster_name   # Cluster name for kubectl
```

### Manage Kubernetes & Helm
```bash
# 1. Connect to EKS
aws eks update-kubeconfig --region us-east-1 --name $(terraform output -raw eks_cluster_name)

# 2. Verify nodes
kubectl get nodes

# 3. Helm Operations
cd helm/microservices
helm lint .

# Deploy (using dev overrides)
helm upgrade --install petclinic . \
  --namespace petclinic --create-namespace \
  -f overrides/dev.yaml \
  --set global.ecrRegistry=$(aws sts get-caller-identity --query Account --output text).dkr.ecr.us-east-1.amazonaws.com
```

### Validate DRY Compliance
```bash
./scripts/check-dry.sh
```

### Format All Files
```bash
terraform fmt -recursive
```

### Validate Configuration
```bash
cd environments/dev
terraform validate
```

## ğŸ“ Variable Organization

### General
- `project_name`, `environment`, `aws_region`

### Networking
- `vpc_cidr`, `public_subnet_cidrs`, `private_subnet_cidrs`
- `data_availability_zone`, `allowed_cidr_blocks`

### Jenkins Master
- `jenkins_instance_name`, `jenkins_instance_type`
- `jenkins_root_volume_size`, `jenkins_extra_volume_size`

### SonarQube Server
- `sonarqube_instance_name`, `sonarqube_instance_type`
- `sonarqube_root_volume_size`, `sonarqube_extra_volume_size`

### Worker Nodes
- `worker_instance_name`, `worker_instance_type`
- `worker_root_volume_size`, `worker_extra_volume_size`

### Common EC2
- `ami`, `key_name`, `associate_public_ip`
- `iam_instance_profile`, `user_data_replace_on_change`

### Database
- `db_instance_class`, `db_allocated_storage`, `db_username`

### EKS
- `cluster_version`

## ğŸ“Š Tool Installation Matrix

| Tool | Jenkins Master | Worker Nodes | SonarQube |
|:---|:---:|:---:|:---:|
| Java 21 (Corretto) | âœ… | âœ… | âœ… |
| Docker + Compose V2 | âœ… | âœ… | âœ… |
| AWS CLI v2 | âœ… | âœ… | âœ… |
| Jenkins (service) | âœ… | | |
| Maven 3.9.6 | | âœ… | |
| Kubectl v1.29 | | âœ… | |
| Helm v3 | | âœ… | |
| SonarQube (stack) | | | âœ… |
| Trivy | âœ… | | âœ… |
| Checkov | âœ… | | âœ… |

## ğŸ¯ Environment Sizing Guide

### Dev (Cost-Optimized)
- VPC: `10.0.0.0/16`
- AZs: 2
- Jenkins: `t3.large`, 20GB root, 10GB extra
- SonarQube: `t2.medium`, 20GB root
- Public IPs: Yes
- Security: `0.0.0.0/0`

### Staging (Balanced)
- VPC: `10.1.0.0/16`
- AZs: 2
- Jenkins: `t3.large`, 30GB root, 20GB extra
- SonarQube: `t2.medium`, 30GB root, 10GB extra
- Public IPs: Yes
- Security: `0.0.0.0/0`

### Prod (High Availability)
- VPC: `10.2.0.0/16`
- AZs: 3 (Multi-AZ)
- Jenkins: `t3.xlarge`, 50GB root, 50GB extra
- SonarQube: `t3.large`, 50GB root, 30GB extra
- Public IPs: No (private)
- Security: `10.0.0.0/8` (restricted)
- DB: `db.r6g.large`

## âš™ï¸ Adding New Environment

1. **Create directory:**
   ```bash
   mkdir -p environments/new-env
   ```

2. **Copy base files:**
   ```bash
   cd environments/new-env
   cp ../dev/{backend.tf,providers.tf,versions.tf,variables.tf} .
   ```

3. **Update backend.tf:**
   ```hcl
   key = "tfstate/new-env/terraform.tfstate"
   ```

4. **Create terraform.tfvars:**
   ```hcl
   environment = "new-env"
   vpc_cidr = "10.X.0.0/16"  # Choose unique CIDR
   # ... other values
   ```

5. **Create main.tf** with module composition

6. **Initialize and deploy:**
   ```bash
   terraform init
   terraform plan
   ```

## ğŸ” Troubleshooting

### "No such file or directory"
- Ensure you're in the correct environment directory
- Run `terraform init` first

### "Backend configuration changed"
- Run `terraform init -reconfigure`

### "Variable not defined"
- Check `variables.tf` has the variable
- Check `terraform.tfvars` provides a value (if required)

### "Duplicate resource"
- Check module isn't called multiple times
- Verify resource names are unique

## âœ… Best Practices Checklist

- [ ] Run `./scripts/check-dry.sh` before committing
- [ ] Format code with `terraform fmt -recursive`
- [ ] Validate with `terraform validate`
- [ ] Use `terraform plan` before `apply`
- [ ] Review plan output carefully
- [ ] Tag all resources appropriately
- [ ] Use appropriate instance sizes per environment
- [ ] Enable encryption for sensitive data
- [ ] Use private instances in production
- [ ] Document any custom changes

## ğŸ“š File Purposes

| File | Purpose |
|------|---------|
| `backend.tf` | S3 state backend config (only `key` differs) |
| `providers.tf` | AWS provider with default tags |
| `versions.tf` | Terraform & provider versions |
| `variables.tf` | Variable definitions (same across envs) |
| `terraform.tfvars` | Environment-specific values |
| `main.tf` | Infrastructure composition + Ansible inventory generation |
| `outputs.tf` | IPs, URLs, tool_mapping, ansible_command |
| `keypair.tf` | SSH key pairs |
| `templates/ansible_inventory.tftpl` | Jinja template for Ansible INI inventory |

## ğŸ› ï¸ Maintenance

### Update All Environments
```bash
# Test in dev first
cd environments/dev
terraform plan
terraform apply

# Then staging
cd ../staging
terraform plan
terraform apply

# Finally prod
cd ../prod
terraform plan
terraform apply
```

### Sync Variable Definitions
```bash
# Copy updated variables.tf to all environments
cp environments/dev/variables.tf environments/staging/
cp environments/dev/variables.tf environments/prod/
```

### Validate All Environments
```bash
for env in dev staging prod; do
  echo "Validating $env..."
  cd environments/$env
  terraform validate
  cd ../..
done
```

## ğŸ“ Key Principles

1. **DRY**: Don't repeat variable definitions
2. **Consistency**: Same structure across all environments
3. **Clarity**: Organized, well-documented code
4. **Modularity**: Reusable modules for all resources
5. **Security**: Environment-appropriate security settings
6. **Validation**: Automated checks for consistency

## ğŸ“ Support

- **Documentation**: See `README.md` for detailed info
- **Changes**: See `REFACTORING_SUMMARY.md` for refactoring details
- **Validation**: Run `./scripts/check-dry.sh` for automated checks
